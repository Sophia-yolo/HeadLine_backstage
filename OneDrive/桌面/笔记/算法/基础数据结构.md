## 数据结构

三个等式

- 程序 = 算法 + 数据结构
- 程序设计 = 算法 + 数据结构 + 编程范式
- **数据结构 = 结构定义 + 结构操作**

> 1. 数据的集合
> 2. 数据之间的关系
> 3. 应用在数据上的方法和操作

逻辑结构

1. 集合结构
2. 线性结构：栈、队列
3. 树形结构
4. 图形结构

物理结构

1. 顺序存储
2. 链式存储





## 算法复杂度

### 时间复杂度

> 没有循环语句，记作`O(1)`，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作`O（n）`，也叫线性阶。

常见的时间复杂度有：

- `O(1)`: 常数复杂度
- `O(log n)`: 对数复杂度
- `O(n)`:  线性时间复杂度
- `O(n^2)`:  平方
- `O(n^3)`:  立方
- `O(2^n)`:  指数
- `O(n!)`:  阶乘

![img](https://user-gold-cdn.xitu.io/2019/8/20/16cac3540b752726?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 空间复杂度

> 一个程序的空间复杂度是指运行完一个程序所需内存的大小。





## 数组

`JS`不是严格意义上的数组👉`JS`的数组元素可以是任意类型，内存地址是不连续的

优点：

> 1. 根据索引查询元素时速度快
> 2. 存储大量的数据
> 3. 按照索引去遍历数组
> 4. 定义方便，访问很灵活

缺点：

> 1. 根据内容查找慢
> 2. 增加、删除效率慢

### 结构操作

#### 插入

![图片](http://139.196.138.42/wp-content/uploads/2021/01/dWtvTZh20210123.png)]

结果👇👇👇

![图片](http://139.196.138.42/wp-content/uploads/2021/01/iYyFvkr20210123.png)

> - 不能空着插，必须连续
> - 插入位置后的所有元素向后移动一位
>   - **从后开始**移动，每个元素向后移动一位
> - 必须要改变的属性：length + 1

#### 删除

![图片](http://139.196.138.42/wp-content/uploads/2021/01/Mbe2n2c20210123.png)](h

结果👇👇👇

![图片](http://139.196.138.42/wp-content/uploads/2021/01/PBMtVqA20210123.png)

> - 不是真的删除，而是告诉系统这个地址的存储区可以被占用、被覆盖
> - 将后面所有的元素整体向前移动一位
>   - 相当于要删除的位置的值被覆写
>   - 最后一个值怎么覆写？
>     - 直接将length – 1
> - 必须要改变的属性：length – 1

### 双指针







## 链表

> 1. web浏览器历史管理
> 2. 底层内存管理
> 3. 实现哈希表
> 4. 文件系统

### 单向链表

![image-20210515095456806](C:\Users\Area1\AppData\Roaming\Typora\typora-user-images\image-20210515095456806.png)

### 双向链表

![image-20210515095436428](C:\Users\Area1\AppData\Roaming\Typora\typora-user-images\image-20210515095436428.png)



## 堆栈

- `FILO`（First In Last Out）、`LIFO`。类比装书的箱子，一头是堵死的
- 也是顺序结构

### 结构定义

- 需要连续的存储空间（有大小限制）
- 容量
- 栈顶指针【top】：对于空栈，top = -1，为0可不合适
- 数据类型

### 结构操作

- push()：入栈
- pop()：出栈
- 出栈：top – 1 // 需要判空
- 入栈：top + 1，存值 // 需要判满

#### 清空数组

> 1. length = 0;
> 2.  = []
> 3. splice()

### `JS`的调用栈

#### 执行上下文

就是当前`JS`代码被解析和执行所在环境的抽象概念

> `JS`中的任何代码就是在执行上下问中运行的（执行环境）

类型

1. 全局执行上下文（默认）

   > - 创建全局对象
   > - 将this执行全局对象

2. 函数执行上下文

   > 每次调用函数的时候，会为这个函数创建一个新的执行上下文

3. `Eval()`函数

#### 执行栈

先进后出，用于存储在代码执行期间创建的所有执行上下文

> `JS`引擎创建一个新的全局执行上下文来并且将这个执行上下文push当前的执行栈中



#### 递归

重复计算，需要同时保存成百上千的调用帧👉容易发生溢出

> 解决办法：尾调用👉尾递归

##### 尾递归

只存在调用帧



### 应用

> 1. 程序的递归
> 2. graham扫描寻找凸图形
> 3. 搜索单调矩阵
> 4. 聚类分析中最邻近分类算法（`KNN`）





## 队列

运算受限的线性表

- FIFO（First In First Out）。类似排队，区分先来后到
- 也是顺序结构，需要连续存储空间（不过也可以用链表实现）
- 受限：只允许表的前端进行删除，在表的后端进行增加

### 结构定义

- 需要连续的存储空间
- 容量
- 队首、队尾
- +元素个数：用来判断队列是否已满，方便**循环队列**解决假溢出问题
- 数据类型

### 常规操作

- 入队操作：enqueue(element)

- 出队操作：dequeue(element)

- 查看队首元素：front()

- 查看队尾：rear()

- 查看队列是否为空：`isEmpty()`

- 假溢出

  - 不能存元素了

  - 实际上可能还没有满：出队操作使队列头部有空位

  - 解决方案：

    循环队列

    - tail走到头了再回到队列前面
    - 使用取余运算确定位置：(tail + 1) % length

### `JS`的异步队列

JavaScript：单线程，同一个时间只能做一件事

任务：同步任务、异步任务

同步任务：在主线程上排队执行的任务，只有早前一个任务执行完毕后，才能够去执行下一个任务

> 缺点：同步任务会阻塞后面的代码 

异步任务：不进入主线程，而进入“任务队列”，只有“任务队列”通知主线程，某个异步任务可以执行了，这个任务才会静茹主线程执行。

> 异步任务：定时器、`ajax`，事件（异步）

事件循环：主线程执行完毕以后，从事件队列中去读取任务队列的过程

### 应用

> 1. 用于实现缓冲区
> 2. 用于实现广度优先搜索
> 3. 实现优先级队列
> 4. 动画库



## 树与二叉树

> 二叉树是一种典型的树树状结构。二叉树是每个节点最多有两个子树的树结构，即“左子树”和“右子树”。

### 二叉树遍历





## 堆与优先队列



## 稳定/非稳定排序算法



## 二分/三分查找



## 查找和哈希表



## 森林与并查集



