## 变量

### 关键字：let

1. 不存在重复声明
2. 块级作用域（在代码块有效），有各自单独的作用域，外层代码块**不受内层代码块的影响**。
3. **不**存在**变量提升**：减少运行时错误
4. 在全局作用域的var下，不影响作用域：只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域（暂时性死区）

**暂时性死区（ temporal dead zone ， `TDZ` ）**

1. 在代码块内，使用 let 命令声明变量之前，该变量都是**不可用**的
2. “暂时性死区”也意味着 `typeof` 不再是一个百分之百安全的操作。

有些“死区”比较隐蔽，不太容易发现。 

```
function bar(x = y, y = 2) { 		//此时 y 还没有声明,属于”死区“
	return [x, y]; 					
} 
bar(); // 报错 
```

如果 y 的默 认值是 x ，就不会报错，因为此时 **x 已经声明**了。 

```
function bar(x = 2, y = x) { 
	return [x, y]; 
} 
bar(); // [2, 2]
```



##### do 表达式

块级作用域可以使用 do 变为表达式，也就是说可以返回值

```
let x = do { 
	let t = f(); 
	t * t + 1; 
}; 
//变量 x 会得到整个块级作用域的返回值（ t * t + 1 ）
```



### 关键字：war

1. 可以重复声明

2. 声明全局作用域

3. 允许变量提升：即变量可以在声明之前使用，值为 undefined

   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta http-equiv="X-UA-Compatible" content="IE=edge">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>点击切换颜色</title>
       <link rel="stylesheet" href="index.css">
   </head>
   <body>
       <div class="conrainer">
           <h2 class="page-header">点击切换颜色</h2>
           <div class="item"></div>
           <div class="item"></div>
           <div class="item"></div>
       </div>
       <script>
           let items = document.getElementsByClassName('item');
           for (var i = 0;i<items.length;i++){
               items[i].onclick = function() {
                   this.style.background = 'pink';
               }
           }
       </script>
   </body>
   </html>

![image-20210418103058820](C:\Users\Area1\AppData\Roaming\Typora\typora-user-images\image-20210418103058820.png)PS：

将 `this.style.background = 'pink';` 改为 `items[i].style.background = 'pink';` 会报错

原因：因为在全局作用域 var 下，最后 i 将执行到 3 。

解决方案：var 改为 let 



#### 循环函数

```js
var funcs = [],
object = {
    a: true,
    b: true,
    c: true
};
for (let key in object) {
    funcs.push(function() {
    console.log(key);
	});
}
funcs.forEach(function(func) {
	func(); // 依次输出 "a"、 "b"、 "c"
});
```

let 使每个函数都能够拥有它自身的 key 变量副本，结果**每个函数都输出了一个 不同的值**。而如果使用 var 来声明 key ，则所有函数都只会输出 "c"



## 常量

### 关键字：`const`

1. 一定要初始化-“赋值”

2. 一般常量使用大写(潜规则)

3. 常量的值不能修改，禁止重复声明已有变量（无论是 var 声明，还是 let 声明）

4. 块级作用域

5. 常量声明不提升：存在**暂时性死区**

6. 对于数组和对象的元素修改，不算是对常量的修改，不会报错

   ```js
   eg1：
   //不会报错
   const TEAN = ['UZI','MXLG','Ming'];
   TEAM.push('Meiko');
   
   eg2：
   if (condition) {
   	const maxItems = 5;
   	// 其他代码
   }
   // maxItems 在代码块外部无法被访问
   ```


> 对象冻结，应该使用 `Object.freeze` 方法。
>
> ```
> const foo = Object.freeze({});
> // 常规模式时，下面一行不起作用； 
> // 严格模式时，该行会报错 
> foo.prop = 123;
> 
> //常量 foo 指向一个冻结的对象，所以添加新属性不起作用
> ```



## 对象

### 顶层对象

1. 浏览器：windows
2. `Node`：global
3. 顶层对象的属性与全局变量是等价的。

### global对象

同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。

- 全局环境中， this 会返回顶层对象。Node 模块和 `ES6` 模块中， this 返回的是当前模块。
-  函数里面的 this ，如果函数不是作为对象的方法运行，而是单纯作为函数运行， this 会指向顶层对象。



## 解构赋值

PS：允许按照一定模式从数组和对象中提取值，对变量进行赋值

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。

#### 基础用法

- 模式匹配：只要等号两边的模式相同，左边的变量就会被赋予对应的值

- ```js
  let [x, y, ...z] = ['a']; 
  x // "a" 
  y // undefined 
  z // []
  ```

  如果解构不成功，变量的值就等于 undefined 。

- 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组

- ```js
  let [x, y] = [1, 2, 3];
  x // 1
  y // 2
  ```

#### 数组的解构

```js
let colors = [ "red" ];

let [ firstColor, secondColor = "green" ] = colors;
//允许在数组任意位置指定默认值
console.log(firstColor); // "red"
console.log(secondColor); // "green"
```

> 不要遗忘初始化器器（即等号 右边的值）

#### 对象的解构

PS：对象的属性没有次序，变量必须与属性**同名**

```js
let node = {
	type: "Identifier",
	name: "foo",
	loc: {
		start: {
			line: 1,
			column: 1
		},
		end: {
			line: 1,
			column: 4
		}
	}
};
let { loc: { start: { line } }} = node; //属性名表达式
// 提取 node.loc.start(变量名与属性名不一致):let { loc: { start: localStart}} = node;
//可以赋值给不同的本地变量名以及添加默认值
//花括号内的右侧， loc 被作为需检查的位置来使用，而不会创建变量绑定。

console.log(start.line); // 1
console.log(start.column); // 1
console.log(value); // undefined
//如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为 undefined
```

#### 字符串的解构赋值

```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

#### 数值/布尔值解构

#### 函数参数的解构赋值

#### 其他

- 剩余项：使用 `...` 语法来将剩余的项目赋值给一个指定的变量

- 嵌套的解构

- 混合解构：对象和数组解构一起用

- 参数解构

- 可以使用圆括号的情况

- ```
  //都是赋值语句，而不是声明语句
  [(b)] = [3]; // 正确
  ({ p: (d) } = {}); // 正确 —— 模式是取数组的第一个成员，模式是 p ，而不是 d
  [(parseInt.prop)] = [3]; // 正确
  ```

#### 用途

1. 交换变量的值
2. 从函数返回多个值
3. 函数参数的定义
4. 提取 `JSON` 数据

```js
JQuery.ajax = function (url, {
 	async = true,
 	beforeSend = function () {},
 	cache = true,
 	complete = function () {},
 	crossDomain = false,
 	global = true,
 // ... more config
}) {
 // ... do stuff
};

```

5. 函数参数的默认

```js
let jsonData = {
 	id: 42,
 	status: "OK",
 	data: [867, 5309]
};
let { id, status, data: number } = jsonData;
console.log(id, status, number);
// 42, "OK", [867, 5309]

```

6. 遍历 Map 结构

```js
// 获取键名
for (let [key] of map) {
 // ...
}
// 获取键值
for (let [,value] of map) {
 // ...
}
```

7. 输入模块的指定方法：加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。



## 字符串扩展

#### 字符的 Unicode 表示法

JavaScript 共有 6 种方法可以表示一个字符：

```js
'\z' === 'z' 		// true
'\172' === 'z' 		// true
'\x7A' === 'z' 		// true
'\u007A' === 'z' 	// true
'\u{7A}' === 'z' 	// true
```

字符以 `UTF-16` 的格式储存，每个字符固定为 2 个字节。

对于那些需要 4 个字节储存的字符（Unicode 码点大于 `0xFFFF` 的字符）， JavaScript 会认为它们是两个字符。

```js
var s = "𠮷";
s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```



#### `codePointAt()`

如果想要十六进制的值，可以使用 `toString` 方法转换一下。

```js
var text = "a" ;
text.length 			//text 字符串的第一个字符不是 BMP 字符，因此它占用了两个码元
console.log(text.charCodeAt(0)); // 55362
console.log(text.charCodeAt(1)); // 57271
console.log(text.charCodeAt(2)); // 97
//codePointAt() 方法的返回值一般与 charCodeAt() 相同，除非操作对象并不是 BMP 字符。
console.log(text.codePointAt(0)); // 134071
console.log(text.codePointAt(1)); // 57271
console.log(text.codePointAt(2)); // 97
```

`codePointAt` 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

```js
function is32Bit(c) {
 return c.codePointAt(0) > 0xFFFF;
}
is32Bit("𠮷") // true
is32Bit("a") // false
```



#### `String.fromCodePoint()` 方法

用于从码点返回对应字符,可以识别大于 `0xFFFF` 的字符

PS：如果 `String.fromCodePoint` 方法有多个参数，则它们会被合并成一个字符串返回



#### 字符串的遍历器接口

PS：遍历器接口—Iterator

```  
for (let codePoint of 'foo') {
 console.log(codePoint)
}
// "f"
// "o"
// "o"
```



#### at()

PS：可以识别 Unicode 编号大于 `0xFFFF` 的字符，返回正确的字符。

```js
'abc'.at(0) // "a"
'𠮷'.at(0) // "𠮷"
```



#### normalize()

PS：用来将字符的不同表示方法统一为同样的形式



#### includes(), `startsWith()`, `endsWith()`

- includes()：返回布尔值，表示是否找到了参数字符串。 
- `startsWith()`：返回布尔值，表示参数字符串是否在原字符串的头部。 
- `endsWith()`：返回布尔值，表示参数字符串是否在原字符串的尾部。



#### repeat()

repeat 方法返回一个新字符串，表示将原字符串重复 n 次

```js
'x'.repeat(3) // "xxx"
'hello'.repeat(2) // "hellohello"
'na'.repeat(0) // ""
```

1. 参数如果是小数，会被取整。

```js
'na'.repeat(2.9) // "nana"
```

2. 如果 repeat 的参数是负数或者 Infinity ，会报错。
3. ，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于 -0 ， repeat 视同为 0。
4. 参数 `NaN` 等同于 0。
5. 如果 repeat 的参数是字符串，则会先转换成数字。



#### `padStart()`，`padEnd()`

PS：`padStart()` 用于头部补全， `padEnd()` 用于尾部补全。

`padStart` 的常见用途

1. 为数值补全指定位数。
2. 提示字符串格式。



#### 模板字符串

1. 声明：引入新的声明字符串的方式： ``(反引号)

2. 内容中可以直接出现换行符

3. 所有模板字符串的空格和换行，都是被保留的 

   > 标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。

4. 变量的拼接

```js
let love = 'blackpink';
let out = `${love}是我最爱！！`;//模板字符串中嵌入变量，需要将变量名写在 ${} 之中。
console.log(out);
```

  

#### 标签模板

PS：处理模板字符串







## 简化对象

```js
let name = '张三';
let change = function(){
	console.log('我们可以改变世界');
}
const school = {
	name,
	change,
	//这是一个函数
	impove(){
		console.log("我们不在犯罪");
	}
}
console.log(school);
//可以输出 name，change……
```



## 箭头函数

1. 声明函数

```js
// a ，b 是形参
let fn = (a,b) =>{
	return a + b;
}
```

2. this 是静态的，this 始终指向函数**声明时**所在作用域下的this的值。

PS：`call`方法：可以改变函数内部的值

3. 不能作为构造实例化对象
4. 不能使用 arguments 变量
5. 简写
   1. 省略小括号：当形参有且只有一个的时候
   2. 省略花括号：当代码只有一条语句的时候，此时 return 必须省略，而且语句的执行结果就是函数的返回值

PS：

fitter()方法

```js
<script>
var ages = [32, 33, 12, 40];
function checkAdult(age) {
    return age >= document.getElementById("ageToCheck").value;
}
function myFunction() {
    document.getElementById("demo").innerHTML = ages.filter(checkAdult);
}
</script>
```

![image-20210418175508790](C:\Users\Area1\AppData\Roaming\Typora\typora-user-images\image-20210418175508790.png)

> 箭头函数适合与 this 无关的回调——定时器、数组的方法回调
>
> 不适合与 this 有关的回调：事件回调、对象的方法



## 形参——实参

1. 函数参数的默认值设置（可初始化）
2. 引入 rest 参数，用于获取函数的实参，用来代替 argument

```js
// ...args = rest 参数
function date(...args){
	console.log(args);		//filter, some, every, map
}
date('112','231','321');
//rest 参数必须放到参数最后
```



## 扩展运算符

PS：能够将【数组】转换为逗号分隔的【参数序列】

```js
const TEAN = ['UZI','MXLG','Ming'];
function active(){
	console.log(arguemnt);
}
active(...TEAN);	//等同active(''UZI','MXLG','Ming'')
```

#### 应用

1. 数组的合并

```js
const kuaizi = ['王太利','肖扬'];
const f4 = ['UZI','MXLG','Ming'];
const together = [...kuazi,...f4];
console.log(together);
```

2. 数组的克隆

```js
const f4 = ['UZI','MXLG','Ming'];
const other = [...f4];
```

3. 将伪数组转为真正的数组

```js
const divs = document.querySelectorAll('div');
const divArr = [...divs];
```



## symbol

PS：`JavaScript` 的第七种数据类型

1. 创建Symbol

```js
let s = Symbol();
```

2. `Symbol.for` 创建

```js
let s = Symbol.for('');
```

3. 不能与其他数据进行运算

> 数据类型：`USONB`（you are so NB）
>
> 1. u—undefined
> 2. s—string   symbol
> 3. o—object
> 4. n—null    number
> 5. b—boolean

#### Symbol的使用





## 迭代器





## 生成器

1. 特殊的函数：异步编程、纯回调函数

```
//声明
function * gen(arg){
	// yield 函数代码的分隔符,调用四次
	consol.log(arg)
	yield '一只没有耳朵';
	yield '一只没有尾巴';
	yield '奇怪';	
}
let chang = gen();
//调用
// next()可以传入实参
chang.next();
```



**异步编程**：文件操作、网络操作（`ajax`、request）、数据库操作



## Promise

1. 构造函数：Promise (`excutor`){}
2. `promise.prototype.then`
3. `promise.prototype.catch`

