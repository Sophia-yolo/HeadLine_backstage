类似于一个公司由各个部门组成，一个工程也由各个模块组成，高内聚低耦合，各司其职。先理解一下概念

### 作用域

定义：运行时变量、函数、对象可访问性
作用域决定了代码中变量和其他资源的可见性

#### 全局作用域

```
    var a = 1;    
    window.a; // 1    
    global.a; // 1 
```

#### 局部作用域

```
    function a(){
        var v = 1;
    }
    window.v; // undefined
```

如果在传统 `js` 写法中，引入多个 `script`，就很容易造成全局作用域冲突而导致不可预测的问题：

```
	<body>
    	<script scr="./moduleA.js"></sciprt>
        <script scr="./moduleB.js"></sciprt>
        <script scr="./moduleC.js"></sciprt>
    </body>
```

改进步骤一，使用变量作用域形成局部作用域：

```
// 定义模块内的局部作用域，以moduleA为例
    var Susan = {
    	name: "susan",
        sex: "female",
        tell: function(){
        	console.log("im susan")
        }
    }
```

但是步骤一无法保证模块属性内部安全性，比如可能不小心改掉属性值，可以通过立即执行函数进行改写，形成闭包。
那么可以进行改进步骤二：
`ps`：什么是立即执行函数（参考资料：https://blog.csdn.net/qq_33457248/article/details/80773496 ）？
		  什么是自由变量（参考资料：https://www.cnblogs.com/pssp/p/5206240.html）？简单来说是跨作用域的变量

```
	// 定义模块内的闭包作用域（模块作用域），以moduleA为例
    var SusanModule = (function(){
        var Susan = {
        // 自由变量
    	name: "susan",
        // 自由变量
        sex: "female",
        // 只允许访问tell方法，不能访问和修改其他属性
        return {
        	tell: function(){
        		console.log("im susan")
        	}
        }
    })()
```

对于步骤二还有一种写法，推荐使用这种写法，也是早期模块实现的方法

```
	// 定义模块内的闭包作用域（模块作用域），以moduleA为例
    (function(window){
    	var name = "susan"
        var sex = "female"
        functioon tell(){
        	console.log("im ", this.name)
        }
        window.susanModule = {tell}
    })(window)// window作为参数传给
```

####  模块化的优点

- 模块化的封装
- 重用性
- 解除耦合



#### 模块化方案进化史

### **AMD**

Asynchronous Module Definition(异步模块定义)

### COMMONJS

```js
// 通过require函数来引用
const math = require("./math");

// 通过exports将其导出
exports.getSum = function(a,b){
	return a + b;
}
```
### ES6 MODULE（使用最多）

```js
// 通过import函数来引用
import math from "./math";

// 通过export将其导出
export function sum(a, b){
	return a + b;
}
```